---
import type { SanityImageSource } from "@sanity/image-url/lib/types/types";
import {
  getResponsiveImageSet,
  extractImageMetadata,
  getLQIPUrl,
  getOptimizedImageUrl,
  IMAGE_QUALITY,
  type ResponsiveImageSource,
  type ImageMetadata
} from '../lib/sanityImage';

interface Props {
  image: SanityImageSource;
  alt: string;
  caption?: string;
  credit?: string;
  alignment?: 'left' | 'center' | 'right';
  size?: 'small' | 'medium' | 'large' | 'full';
  aspectRatio?: '4:5' | '1:1' | '16:9' | '9:16' | number;
  className?: string;
  loading?: 'lazy' | 'eager';
  quality?: number;
  formats?: string[];
  sizes?: string;
  placeholder?: 'blur' | 'color' | 'empty';
  priority?: boolean;
  // Visual editing props
  _key?: string;
  _type?: string;
}

const {
  image,
  alt,
  caption,
  credit,
  alignment = 'center',
  size = 'medium',
  aspectRatio = '4:5',
  className = '',
  loading = 'lazy',
  quality = IMAGE_QUALITY.CARD,
  formats = ['avif', 'webp', 'jpg'],
  sizes,
  placeholder = 'blur',
  priority = false,
  _key,
  _type
} = Astro.props;

// Convert aspect ratio to numeric value
const getAspectRatioValue = (ratio: string | number): number => {
  if (typeof ratio === 'number') return ratio;
  const [width, height] = ratio.split(':').map(Number);
  return width / height; // Changed: width/height instead of height/width for CSS aspect-ratio
};

const aspectValue = getAspectRatioValue(aspectRatio);

// Define responsive breakpoints based on size
const getImageWidths = (size: string): number[] => {
  switch (size) {
    case 'small': return [300, 400, 600];
    case 'medium': return [400, 600, 800, 1200];
    case 'large': return [600, 800, 1200, 1600];
    case 'full': return [800, 1200, 1600, 2000];
    default: return [400, 600, 800, 1200];
  }
};

// Generate automatic sizes attribute if not provided
const getAutoSizes = (size: string): string => {
  switch (size) {
    case 'small': return '(max-width: 768px) 100vw, 300px';
    case 'medium': return '(max-width: 768px) 100vw, 600px';
    case 'large': return '(max-width: 768px) 100vw, 800px';
    case 'full': return '100vw';
    default: return '(max-width: 768px) 100vw, 600px';
  }
};

const imageWidths = getImageWidths(size);
const imageSizes = sizes || getAutoSizes(size);

// Generate responsive image sets (only if image exists)
const responsiveImageSets: ResponsiveImageSource[] = image ? getResponsiveImageSet(
  image,
  imageWidths,
  formats,
  aspectValue,
  quality
) : [];

// Extract metadata for advanced features
const metadata: ImageMetadata = image ? extractImageMetadata(image) : {};

// Generate placeholder (BlurHash preferred, fallback to LQIP)
let placeholderUrl: string | null = null;
if (image && placeholder === 'blur') {
  // Try BlurHash first (better quality but only works client-side during hydration)
  if (metadata.blurHash) {
    // For SSR, we'll use LQIP as initial placeholder
    // Client-side script can upgrade to BlurHash if needed
    placeholderUrl = metadata.lqip || getLQIPUrl(image);
  } else {
    // Fall back to LQIP
    placeholderUrl = getLQIPUrl(image);
  }
}

// Calculate width and height from largest image in responsive set
const largestWidth = imageWidths[imageWidths.length - 1];
const imageWidth = largestWidth;
const imageHeight = Math.round(largestWidth / aspectValue);

// Generate fallback URL (only if image exists)
const fallbackUrl = image ? getOptimizedImageUrl(
  image,
  imageWidths[0],
  Math.round(imageWidths[0] / aspectValue),
  quality
) : null;

// Determine loading strategy
const imageLoading = priority ? 'eager' : loading;
const fetchPriority = priority ? 'high' : 'auto';

---

<figure
  class={`image-container content-media-narrow image-${alignment} image-${size} ${className}`}
  data-sanity={_key ? `${_type}.${_key}` : _type}
>
  {image ? (
    <div
      class="image-wrapper"
      style={`--aspect-ratio: ${aspectValue}`}
    >
      {placeholderUrl && (
        <div
          class="image-placeholder"
          style={`background-image: url(${placeholderUrl})`}
          aria-hidden="true"
        />
      )}
      <picture>
        {responsiveImageSets
          .filter((format) => format.srcset.length > 0)
          .map((format) => (
          <source
            srcset={format.srcset}
            sizes={imageSizes}
            type={`image/${format.format}`}
          />
        ))}
        <img
          src={fallbackUrl || ''}
          alt={alt}
          width={imageWidth}
          height={imageHeight}
          loading={imageLoading}
          decoding="async"
          fetchpriority={fetchPriority}
          sizes={imageSizes}
          class="image"
        />
      </picture>
    </div>
  ) : (
    <div class="image-missing">
      <span>Bilde ikke tilgjengelig</span>
    </div>
  )}

  {(caption || credit) && (
    <figcaption class="image-caption">
      {caption && <span class="caption-text">{caption}</span>}
      {credit && <span class="credit-text">{credit}</span>}
    </figcaption>
  )}
</figure>

<script>
  // Client-side image load detection
  document.addEventListener('astro:page-load', () => {
    const images = document.querySelectorAll('.image-wrapper .image');

    images.forEach((img) => {
      const wrapper = img.closest('.image-wrapper');
      if (!wrapper) return;

      // Check if already loaded
      if ((img as HTMLImageElement).complete) {
        wrapper.classList.add('image-loaded');
      } else {
        // Listen for load event
        img.addEventListener('load', () => {
          wrapper.classList.add('image-loaded');
        }, { once: true });
      }
    });
  });
</script>

<style>
  .image-container {
    margin: 2rem 0;
  }

  .image-container.image-left {
    text-align: left;
  }

  .image-container.image-center {
    text-align: center;
  }

  .image-container.image-right {
    text-align: right;
  }

  /* Modern image wrapper with blur-up effect */
  .image-wrapper {
    position: relative;
    overflow: hidden;
    aspect-ratio: var(--aspect-ratio);
    content-visibility: auto; /* Performance: render only when visible */
    display: inline-block;
    max-width: 100%;
  }

  /* Size constraints */
  .image-small .image-wrapper {
    max-width: 300px;
  }

  .image-medium .image-wrapper {
    max-width: 600px;
  }

  .image-large .image-wrapper {
    max-width: 800px;
  }

  .image-full .image-wrapper {
    width: 100%;
  }

  /* LQIP/BlurHash placeholder with blur-up effect */
  .image-placeholder {
    position: absolute;
    inset: 0;
    background-size: cover;
    background-position: center;
    filter: blur(20px);
    transform: scale(1.1); /* Prevent blur edges from showing */
    transition: opacity 400ms ease-out;
    z-index: 1;
  }

  .image-loaded .image-placeholder {
    opacity: 0;
  }

  /* Picture element (contains sources) */
  .image-wrapper picture {
    position: relative;
    z-index: 2;
    display: block;
    width: 100%;
    height: 100%;
  }

  /* Image element */
  .image {
    position: relative;
    z-index: 2;
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity 400ms ease-out;
  }

  .image-loaded .image {
    opacity: 1;
  }

  /* Dark mode enhancement */
  @media (prefers-color-scheme: dark) {
    .image {
      filter: brightness(0.8) contrast(1.2);
    }
  }

  /* Accessibility: Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .image-placeholder,
    .image {
      transition: none;
    }
  }

  /* Caption styling */
  .image-caption {
    margin-top: 0.5rem;
    font-size: 0.9rem;
  }

  .caption-text {
    display: block;
  }

  .credit-text {
    display: block;
    font-style: italic;
    margin-top: 0.25rem;
  }

  /* Missing image placeholder */
  .image-missing {
    background: #f5f5f5;
    border: 2px dashed #ddd;
    padding: 2rem;
    text-align: center;
    aspect-ratio: 4/5;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  @media (prefers-color-scheme: dark) {
    .image-missing {
      background: #2a2a2a;
      border-color: #444;
      color: #aaa;
    }
  }
</style>
